<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JSON Offsets - Belatstrap</title>
  <link rel="icon" type="image/png" href="https://i.imgur.com/hoNzUGn.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Gravitas+One&family=Special+Gothic+Expanded+One&family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="cursor.css" />
  <link rel="stylesheet" href="trail.css" />
  <script src="trail.min.js" defer></script>
  <meta name="description" content="JSON Offsets - Complete memory offsets in JSON format." />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brandRed: '#e10600',
            ink: '#0b0b0b',
            paper: '#ffffff',
            fog: '#f4f4f4',
            line: 'rgba(255, 255, 255, 0.14)',
          }
        }
      }
    }
  </script>
  <style>
    body { background-color: #000 !important; color: #fff !important; font-family: "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; position: relative; min-height: 100vh; }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -2;
      background: url('https://i.imgur.com/naK1hruh.jpg');
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      filter: grayscale(20%) brightness(90%);
      opacity: 0.3;
      transform: translateZ(0);
      pointer-events: none;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background: rgba(0, 0, 0, 0.55);
      pointer-events: none;
    }

    section.bg-black { background-color: transparent !important; }
    .font-serif { font-family: "Gravitas One", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif !important; }
    .font-sans { font-family: "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; }
    .font-gothic { font-family: "Special Gothic Expanded One", "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; }
    .page-enter { animation: pageEnter 700ms cubic-bezier(0.22, 1, 0.36, 1) both; }
    @keyframes pageEnter {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .lux-link { position: relative; }
    .lux-link::after { content: ""; position: absolute; left: 0; bottom: -2px; width: 100%; height: 1px; background: #e10600; transform: scaleX(0); transform-origin: left; transition: transform 240ms ease; }
    .lux-link:hover::after { transform: scaleX(1); }
    .glow-cta { position: relative; }
    .glow-cta::before { content: ""; position: absolute; inset: -2px; background: radial-gradient(60% 60% at 50% 50%, rgba(225, 6, 0, 0.55) 0%, rgba(225, 6, 0, 0) 70%); filter: blur(10px); opacity: 0.85; z-index: -1; }
    .glow-cta { animation: ctaPulse 2.6s ease-in-out infinite; }
    @keyframes ctaPulse {
      0%, 100% { transform: translateY(0); box-shadow: 0 0 0 rgba(225, 6, 0, 0); }
      50% { transform: translateY(-1px); box-shadow: 0 0 34px rgba(225, 6, 0, 0.35); }
    }

    .motion {
      transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease, opacity 160ms ease, background-color 160ms ease, border-color 160ms ease;
      will-change: transform;
    }

    .motion:active {
      transform: scale(0.98);
    }

    .glow-primary {
      box-shadow: 0 0 0 rgba(225, 6, 0, 0);
    }

    .glow-primary:hover {
      box-shadow: 0 0 26px rgba(225, 6, 0, 0.28);
      filter: drop-shadow(0 0 10px rgba(225, 6, 0, 0.22));
    }

    /* Spider Web Canvas Overlay */
    #spiderWebCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1;
      opacity: 1;
    }

    /* JSON Display Styles */
    .json-container {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgba(225, 6, 0, 0.3);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      transition: all 0.3s ease;
    }
    
    .json-container:hover {
      border-color: rgba(225, 6, 0, 0.6);
      box-shadow: 0 25px 70px rgba(225, 6, 0, 0.2);
    }

    .json-header {
      background: linear-gradient(135deg, rgba(225, 6, 0, 0.1), rgba(225, 6, 0, 0.05));
      border-bottom: 1px solid rgba(225, 6, 0, 0.2);
    }

    .json-content {
      font-family: 'Courier New', monospace;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 12px;
      line-height: 1.4;
      max-height: 70vh;
      overflow-y: auto;
    }

    .json-content::-webkit-scrollbar {
      width: 8px;
    }

    .json-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    .json-content::-webkit-scrollbar-thumb {
      background: rgba(225, 6, 0, 0.5);
      border-radius: 4px;
    }

    .json-content::-webkit-scrollbar-thumb:hover {
      background: rgba(225, 6, 0, 0.7);
    }

    /* JSON Syntax Highlighting */
    .json-key { color: #88ccff; }
    .json-string { color: #aaffaa; }
    .json-number { color: #ffcc88; }
    .json-boolean { color: #ff88cc; }
    .json-null { color: #888888; }
    .json-bracket { color: #ffffff; }

    /* Code Editor Styles (from dumped.html) */
    .code-editor {
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 8px;
    }

    /* Scrollbar Styles */
    .code-editor::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    .code-editor::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 6px;
    }

    .code-editor::-webkit-scrollbar-thumb {
      background: #e10600;
      border-radius: 6px;
    }

    .code-editor::-webkit-scrollbar-thumb:hover {
      background: #ff1a1a;
    }
  </style>
</head>
<body class="text-white bg-black font-sans page-enter">
  <canvas id="spiderWebCanvas"></canvas>
  <div id="custom-cursor" aria-hidden="true"></div>
  
  <!-- NAVIGATION -->
  <nav id="site-nav" class="fixed top-0 left-0 right-0 z-50 bg-black/90 backdrop-blur-md border-b border-line">
    <div class="max-w-[1400px] mx-auto px-6 py-4 flex justify-between items-center">
      <div class="flex items-center gap-4">
        <a href="strapper.html" class="flex items-center gap-3">
          <img src="https://i.imgur.com/hoNzUGn.png" alt="Belatstrap logo" class="h-12 w-12 object-contain flex-shrink-0" loading="eager" />
          <span class="text-xs tracking-[0.28em] uppercase">Belatstrap</span>
        </a>
        <a href="https://discord.com/invite/3az9TtVCkA" target="_blank" rel="noopener" class="inline-flex items-center justify-center ml-2 hover:opacity-80 transition" aria-label="Join Discord">
          <img src="https://i.imgur.com/mmgMkV7.png" alt="Discord" class="h-5 w-5 object-contain" />
        </a>
      </div>
      <div class="hidden md:flex gap-10 text-xs tracking-[0.28em] uppercase">
        <a href="strapper.html#features" class="lux-link hover:opacity-60 transition">Features</a>
        <a href="about.html" class="lux-link hover:opacity-60 transition">About</a>
        <a href="note.html" class="lux-link hover:opacity-60 transition">Note</a>
        <a href="strapper.html#download" class="lux-link hover:opacity-60 transition">Download</a>
        <a href="fflags.html" class="lux-link hover:opacity-60 transition text-brandRed">Offsets</a>
        <a href="strapper.html#faq" class="lux-link hover:opacity-60 transition">FAQ</a>
      </div>
    </div>
  </nav>

  <!-- MAIN CONTENT -->
  <section class="min-h-screen w-full flex items-center justify-center px-6 py-20">
    <div class="max-w-6xl w-full">
      <div class="json-container p-8" data-aos="fade-up">
        <!-- Header -->
        <div class="json-header p-6 -m-8 mb-8 rounded-t-lg">
          <div class="flex justify-between items-center mb-8">
            <a href="fflags.html" class="lux-link text-brandRed hover:text-brandRed/80 transition-colors flex items-center gap-2">
              <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
              </svg>
              Back to Offsets
            </a>
          </div>

          <div class="flex flex-col items-center">
            <h2 class="font-serif text-3xl md:text-4xl font-semibold mb-2">
              <span class="text-brandRed font-sans tracking-[0.02em]">JSON</span> OFFSETS
            </h2>
            <p class="text-center text-white/70">Complete Roblox Fast Flags Memory Offsets in JSON Format</p>
          </div>
        </div>

        <!-- Search Input -->
        <div class="mb-6">
          <input 
            type="text" 
            id="searchInput" 
            placeholder="Search offsets... (e.g., Audio, Render, Avatar)"
            class="w-full px-4 py-3 bg-black/50 border border-brandRed/30 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-brandRed/60 focus:ring-2 focus:ring-brandRed/20 transition-all"
          >
          <div id="searchResults" class="mt-2 text-sm text-gray-400"></div>
        </div>

        <!-- JSON Content -->
        <div class="code-editor p-4 rounded-lg relative">
          <button id="copyIconBtn" type="button" class="absolute top-2 right-2 p-1 rounded bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white transition-colors" title="Copy to clipboard" aria-label="Copy JSON">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
          </button>
          <div id="jsonContent" class="whitespace-pre font-mono text-sm">Loading JSON content...</div>
        </div>
      </div>
    </div>
  </section>

  <script src="https://unpkg.com/aos@2.3.4/dist/aos.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      AOS.init({
        duration: 900,
        easing: 'ease-out-cubic',
        once: true,
      });

      document.body.classList.add('site-ready');

      const cursor = document.getElementById('custom-cursor');
      if (!cursor) return;

      document.body.classList.add('cursor-ready');

      const move = (e) => {
        cursor.style.setProperty('--cursor-x', e.clientX);
        cursor.style.setProperty('--cursor-y', e.clientY);
      };

      window.addEventListener('mousemove', move, { passive: true });
      window.addEventListener('pointermove', move, { passive: true });

      const isInteractive = (el) => {
        if (!el) return false;
        return !!el.closest('a, button, summary, [role="button"], input, textarea, select, label');
      };

      window.addEventListener('mouseover', (e) => {
        if (isInteractive(e.target)) cursor.classList.add('is-pointer');
      }, { passive: true });

      window.addEventListener('mouseout', (e) => {
        if (isInteractive(e.target)) cursor.classList.remove('is-pointer');
      }, { passive: true });

      // Load JSON content
      loadJsonContent();

      const headerCopyBtn = document.getElementById('copyButton');
      const iconCopyBtn = document.getElementById('copyIconBtn');

      async function copyDisplayedJson() {
        const jsonContent = document.getElementById('jsonContent')?.textContent || '';

        try {
          await navigator.clipboard.writeText(jsonContent);
        } catch (err) {
          const textArea = document.createElement('textarea');
          textArea.value = jsonContent;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
        }
      }

      function pulseCopyBtn(btn) {
        if (!btn) return;
        const prev = btn.innerHTML;
        btn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
        `;
        setTimeout(() => {
          btn.innerHTML = prev;
        }, 1200);
      }

      if (headerCopyBtn) {
        headerCopyBtn.addEventListener('click', async () => {
          await copyDisplayedJson();
          pulseCopyBtn(headerCopyBtn);
        });
      }

      if (iconCopyBtn) {
        iconCopyBtn.addEventListener('click', async () => {
          await copyDisplayedJson();
          pulseCopyBtn(iconCopyBtn);
        });
      }
    });

    let allOffsets = [];
    let _loadedJsonObj = null;

    async function loadJsonContent() {
      try {
        let response = await fetch('jsonoffsets.html');
        if (!response.ok) {
          response = await fetch('offsets.json');
        }
        if (!response.ok) {
          throw new Error('Failed to load offsets data');
        }

        const jsonText = await response.text();
        
        // Parse the JSON
        const jsonObj = JSON.parse(jsonText);
        _loadedJsonObj = jsonObj;
        
        // Store all offsets for searching
        allOffsets = Object.entries(jsonObj.fflags).map(([name, value]) => ({ name, value }));

        // Create clean JSON object with only essential fields
        const cleanJson = {
          roblox_version: jsonObj.roblox_version,
          dumped_at: jsonObj.dumped_at,
          total_offsets: Object.keys(jsonObj.fflags).length, // Actual count of fflags
          discord: jsonObj.discord,
          fflags: jsonObj.fflags
        };

        const formattedJson = JSON.stringify(cleanJson, null, 2);
        document.getElementById('jsonContent').innerHTML = highlightJson(escapeAngleOnly(formattedJson));
        return jsonObj;
      } catch (error) {
        console.error('Error loading JSON:', error);
        document.getElementById('jsonContent').innerHTML = '<div class="text-red-400">Error loading JSON content. Make sure you are running the site from a web server (not opening the HTML as file://) and that jsonoffsets.html or offsets.json exists.</div>';
        throw error;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function escapeAngleOnly(text) {
      if (text == null) return '';
      return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    // Search functionality
    document.addEventListener('DOMContentLoaded', function() {
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      
      // Load JSON first, then setup search
      loadJsonContent().then(() => {
        if (searchInput) {
          searchInput.addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();
            
            if (query === '') {
              // Show all offsets
              loadJsonContent();
              searchResults.textContent = '';
              return;
            }
            
            // Filter offsets
            const filteredOffsets = allOffsets.filter(offset => 
              offset.name.toLowerCase().includes(query)
            );
            
            // Update search results count
            searchResults.textContent = `Found ${filteredOffsets.length} matching offset${filteredOffsets.length !== 1 ? 's' : ''}`;
            
            // Display filtered results
            if (filteredOffsets.length > 0) {
              const base = _loadedJsonObj || {};
              const cleanJson = {
                roblox_version: base.roblox_version || 'unknown',
                dumped_at: base.dumped_at || 'unknown',
                total_offsets: filteredOffsets.length, // Actual count of filtered fflags
                discord: base.discord || '',
                fflags: {}
              };

              filteredOffsets.forEach(offset => {
                cleanJson.fflags[offset.name] = offset.value;
              });

              const formattedJson = JSON.stringify(cleanJson, null, 2);
              document.getElementById('jsonContent').innerHTML = highlightJson(escapeAngleOnly(formattedJson));
            } else {
              document.getElementById('jsonContent').innerHTML = '<div class="text-gray-400 text-center py-8">No offsets found matching "' + escapeHtml(query) + '"</div>';
            }
          });
        }
      });
    });

    function highlightJson(json) {
      return json
        .replace(/("[\w]+"):/g, '<span class="json-key">$1</span>:')
        .replace(/: (")([^"]*)(")/g, ': <span class="json-string">"$2"</span>')
        .replace(/: (\d+)/g, ': <span class="json-number">$1</span>')
        .replace(/: (true|false)/g, ': <span class="json-boolean">$1</span>')
        .replace(/: (null)/g, ': <span class="json-null">$1</span>')
        .replace(/([\[\]{},])/g, '<span class="json-bracket">$1</span>');
    }
  </script>
  <script>
    // Multi-Legged Skeletal Creature Cursor Follower
    (function() {
      const canvas = document.getElementById('spiderWebCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      const logoImg = new Image();
      logoImg.crossOrigin = 'anonymous';
      logoImg.src = 'https://i.imgur.com/hoNzUGn.png';

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let mouse = {
          x: canvas.width / 2,
          y: canvas.height / 2
      };

      // Enhanced skeletal creature with multiple legs
      class SkeletalCreature {
          constructor() {
              // Main body position
              this.head = { x: mouse.x, y: mouse.y };
              this.targetX = mouse.x;
              this.targetY = mouse.y;
              this.velocity = { x: 0, y: 0 };
              this.angle = 0;
              this.targetAngle = 0;
              
              // Spinal cord segments
              this.spineSegments = 25;
              this.segmentLength = 8;
              this.spine = [];
              
              for (let i = 0; i < this.spineSegments; i++) {
                  this.spine.push({
                      x: mouse.x,
                      y: mouse.y,
                      angle: 0,
                      size: 8 - (i * 0.22),
                      targetX: mouse.x,
                      targetY: mouse.y
                  });
              }
              
              // Multiple pairs of legs (like a centipede/lizard)
              this.legPairs = 8;
              this.legs = [];
              this.stepCycle = 0;
              this.isMoving = false;
              
              for (let i = 0; i < this.legPairs; i++) {
                  // Left leg
                  this.legs.push({
                      side: 'left',
                      segmentIndex: Math.floor(3 + i * 2.5),
                      phase: (i / this.legPairs) * Math.PI * 2,
                      stepHeight: 0,
                      footX: mouse.x,
                      footY: mouse.y,
                      targetFootX: mouse.x,
                      targetFootY: mouse.y,
                      isLifted: false,
                      upperLength: 20,
                      lowerLength: 18
                  });
                  
                  // Right leg
                  this.legs.push({
                      side: 'right',
                      segmentIndex: Math.floor(3 + i * 2.5),
                      phase: (i / this.legPairs) * Math.PI * 2 + Math.PI,
                      stepHeight: 0,
                      footX: mouse.x,
                      footY: mouse.y,
                      targetFootX: mouse.x,
                      targetFootY: mouse.y,
                      isLifted: false,
                      upperLength: 20,
                      lowerLength: 18
                  });
              }
          }

          update() {
              // Calculate distance to mouse
              const dx = mouse.x - this.head.x;
              const dy = mouse.y - this.head.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Only move if cursor is far enough
              if (distance > 80) {
                  this.targetX = mouse.x;
                  this.targetY = mouse.y;
                  this.isMoving = true;
              } else {
                  this.isMoving = false;
              }
              
              // Smooth velocity-based movement
              const targetVelX = (this.targetX - this.head.x) * 0.015;
              const targetVelY = (this.targetY - this.head.y) * 0.015;
              
              this.velocity.x += (targetVelX - this.velocity.x) * 0.1;
              this.velocity.y += (targetVelY - this.velocity.y) * 0.1;
              
              this.head.x += this.velocity.x;
              this.head.y += this.velocity.y;
              
              // Calculate movement angle
              const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
              if (speed > 0.1) {
                  this.targetAngle = Math.atan2(this.velocity.y, this.velocity.x);
              }
              
              // Smooth angle rotation
              let angleDiff = this.targetAngle - this.angle;
              while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
              while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
              this.angle += angleDiff * 0.1;
              
              // Update step cycle
              if (this.isMoving) {
                  this.stepCycle += speed * 0.3;
              }
              
              // Update spine using FABRIK-like algorithm
              this.updateSpine();
              
              // Update legs
              this.updateLegs();
          }

          updateSpine() {
              // Head follows main position
              this.spine[0].x = this.head.x;
              this.spine[0].y = this.head.y;
              this.spine[0].angle = this.angle;
              
              // Forward pass - follow the head
              for (let i = 1; i < this.spine.length; i++) {
                  const prev = this.spine[i - 1];
                  const curr = this.spine[i];
                  
                  const dx = curr.x - prev.x;
                  const dy = curr.y - prev.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  
                  if (dist > 0) {
                      const angle = Math.atan2(dy, dx);
                      curr.x = prev.x + Math.cos(angle) * this.segmentLength;
                      curr.y = prev.y + Math.sin(angle) * this.segmentLength;
                      curr.angle = angle;
                  }
                  
                  // Add slight serpentine motion
                  const wave = Math.sin(this.stepCycle * 0.15 + i * 0.4) * 2;
                  const perpAngle = curr.angle + Math.PI / 2;
                  curr.x += Math.cos(perpAngle) * wave;
                  curr.y += Math.sin(perpAngle) * wave;
              }
              
              // Backward pass - smooth out the spine
              for (let i = this.spine.length - 2; i >= 0; i--) {
                  const curr = this.spine[i];
                  const next = this.spine[i + 1];
                  
                  const dx = next.x - curr.x;
                  const dy = next.y - curr.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  
                  if (dist > this.segmentLength) {
                      const angle = Math.atan2(dy, dx);
                      next.x = curr.x + Math.cos(angle) * this.segmentLength;
                      next.y = curr.y + Math.sin(angle) * this.segmentLength;
                  }
              }
          }

          updateLegs() {
              this.legs.forEach((leg, index) => {
                  // Get attachment point on spine
                  const segment = this.spine[Math.min(leg.segmentIndex, this.spine.length - 1)];
                  const perpAngle = segment.angle + Math.PI / 2;
                  const offset = leg.side === 'left' ? -1 : 1;
                  
                  const hipX = segment.x + Math.cos(perpAngle) * offset * 8;
                  const hipY = segment.y + Math.sin(perpAngle) * offset * 8;
                  
                  // Calculate walking cycle
                  const cyclePos = Math.sin(this.stepCycle + leg.phase);
                  
                  // Check if leg should step
                  const strideLength = 25;
                  const stepForward = segment.angle + (leg.side === 'left' ? Math.PI / 4 : -Math.PI / 4);
                  
                  if (this.isMoving && cyclePos > 0 && !leg.isLifted) {
                      // Lift leg and set new target
                      leg.isLifted = true;
                      leg.targetFootX = hipX + Math.cos(stepForward) * strideLength;
                      leg.targetFootY = hipY + Math.sin(stepForward) * strideLength;
                  } else if (cyclePos < -0.5) {
                      leg.isLifted = false;
                  }
                  
                  // Animate step
                  if (leg.isLifted) {
                      // Lift foot in arc
                      leg.stepHeight = Math.max(0, Math.sin(cyclePos * Math.PI)) * 15;
                      leg.footX += (leg.targetFootX - leg.footX) * 0.3;
                      leg.footY += (leg.targetFootY - leg.footY) * 0.3;
                  } else {
                      // Foot on ground, drag with body movement
                      leg.stepHeight = 0;
                      leg.footX -= this.velocity.x * 0.5;
                      leg.footY -= this.velocity.y * 0.5;
                  }
              });
          }

          solveIK(startX, startY, endX, endY, upperLength, lowerLength) {
              // Two-bone IK solver
              const dx = endX - startX;
              const dy = endY - startY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Clamp distance
              const maxReach = upperLength + lowerLength;
              const clampedDist = Math.min(distance, maxReach * 0.99);
              
              // Law of cosines for angles
              const upperAngle = Math.acos(
                  (upperLength ** 2 + clampedDist ** 2 - lowerLength ** 2) /
                  (2 * upperLength * clampedDist)
              );
              
              const baseAngle = Math.atan2(dy, dx);
              const angle1 = baseAngle + upperAngle;
              
              const jointX = startX + Math.cos(angle1) * upperLength;
              const jointY = startY + Math.sin(angle1) * upperLength;
              
              return {
                  jointX,
                  jointY,
                  angle1,
                  angle2: Math.atan2(endY - jointY, endX - jointX)
              };
          }

          drawBone(x1, y1, x2, y2, thickness, opacity) {
              const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
              const angle = Math.atan2(y2 - y1, x2 - x1);
              
              ctx.save();
              ctx.globalAlpha = opacity;
              ctx.shadowColor = 'rgba(255, 255, 255, 0)';
              ctx.shadowBlur = 0;
              ctx.translate(x1, y1);
              ctx.rotate(angle);
              
              // Bone shape (wider in middle, tapered at ends)
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.quadraticCurveTo(length * 0.3, -thickness, length * 0.5, -thickness * 0.8);
              ctx.quadraticCurveTo(length * 0.7, -thickness, length, 0);
              ctx.quadraticCurveTo(length * 0.7, thickness, length * 0.5, thickness * 0.8);
              ctx.quadraticCurveTo(length * 0.3, thickness, 0, 0);
              ctx.fill();
              
              // Bone highlights
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(length, 0);
              ctx.stroke();
              
              ctx.restore();
          }

          draw() {
              // Draw spinal cord connective tissue
              ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
              ctx.lineWidth = 5;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.moveTo(this.spine[0].x, this.spine[0].y);
              for (let i = 1; i < this.spine.length; i++) {
                  ctx.lineTo(this.spine[i].x, this.spine[i].y);
              }
              ctx.stroke();

              // Draw legs (behind spine)
              this.legs.forEach((leg, index) => {
                  const segment = this.spine[Math.min(leg.segmentIndex, this.spine.length - 1)];
                  const perpAngle = segment.angle + Math.PI / 2;
                  const offset = leg.side === 'left' ? -1 : 1;
                  
                  const hipX = segment.x + Math.cos(perpAngle) * offset * 8;
                  const hipY = segment.y + Math.sin(perpAngle) * offset * 8;
                  
                  const footX = leg.footX;
                  const footY = leg.footY - leg.stepHeight;
                  
                  const ik = this.solveIK(hipX, hipY, footX, footY, leg.upperLength, leg.lowerLength);
                  
                  const opacity = 0.7;
                  
                  // Upper leg bone
                  this.drawBone(hipX, hipY, ik.jointX, ik.jointY, 3, opacity);
                  
                  // Lower leg bone
                  this.drawBone(ik.jointX, ik.jointY, footX, footY, 2.5, opacity);
                  
                  // Joints
                  ctx.save();
                  ctx.globalAlpha = opacity;
                  ctx.fillStyle = '#c0c0c0';
                  ctx.beginPath();
                  ctx.arc(hipX, hipY, 4, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.beginPath();
                  ctx.arc(ik.jointX, ik.jointY, 3.5, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.beginPath();
                  ctx.arc(footX, footY, 3, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.restore();
              });

              // Draw ribs
              for (let i = 3; i < this.spine.length - 3; i += 2) {
                  const segment = this.spine[i];
                  const opacity = (1 - (i / this.spine.length)) * 0.5;
                  const ribLength = 22 - (i * 0.5);
                  
                  if (ribLength > 5) {
                      const perpAngle = segment.angle + Math.PI / 2;
                      
                      // Left rib
                      const leftEndX = segment.x + Math.cos(perpAngle) * -ribLength;
                      const leftEndY = segment.y + Math.sin(perpAngle) * -ribLength;
                      this.drawBone(segment.x, segment.y, leftEndX, leftEndY, 2, opacity);
                      
                      // Right rib
                      const rightEndX = segment.x + Math.cos(perpAngle) * ribLength;
                      const rightEndY = segment.y + Math.sin(perpAngle) * ribLength;
                      this.drawBone(segment.x, segment.y, rightEndX, rightEndY, 2, opacity);
                  }
              }

              // Draw vertebrae
              for (let i = this.spine.length - 1; i >= 0; i--) {
                  const segment = this.spine[i];
                  const opacity = 1 - (i / this.spine.length) * 0.3;
                  
                  ctx.save();
                  ctx.globalAlpha = opacity;
                  
                  // Outer glow
                  ctx.fillStyle = 'rgba(220, 220, 220, 0.3)';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size + 2.5, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // Main vertebra
                  ctx.fillStyle = '#e8e8e8';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // Inner ring detail
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 1.5;
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size * 0.65, 0, Math.PI * 2);
                  ctx.stroke();
                  
                  // Spinal canal (center hole)
                  ctx.fillStyle = '#444';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size * 0.4, 0, Math.PI * 2);
                  ctx.fill();
                  
                  ctx.restore();
              }

              // Draw logo as creature head
              const head = this.spine[0];
              if (logoImg && logoImg.complete && logoImg.naturalWidth > 0) {
                const size = 34;
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(head.angle);
                ctx.drawImage(logoImg, -size / 2, -size / 2, size, size);
                ctx.restore();
              }
          }
      }

      // Create creature
      const creature = new SkeletalCreature();

      function animate() {
          // Clear every frame for crisp rendering (no blurry smear)
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          creature.update();
          creature.draw();

          requestAnimationFrame(animate);
      }

      // Mouse movement
      document.addEventListener('mousemove', (e) => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
      });

      // Resize
      window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
      });

      animate();
    })();
  </script>
</body>
</html>
