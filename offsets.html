<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Offsets - Belatstrap</title>
  <link rel="icon" type="image/png" href="https://i.imgur.com/hoNzUGn.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Gravitas+One&family=Special+Gothic+Expanded+One&family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="cursor.css" />
  <link rel="stylesheet" href="trail.css" />
  <script src="trail.min.js" defer></script>
  <meta name="description" content="Belatstrap Offsets - Memory offsets and technical documentation for advanced users." />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brandRed: '#e10600',
            ink: '#0b0b0b',
            paper: '#ffffff',
            fog: '#f4f4f4',
            line: 'rgba(255, 255, 255, 0.14)',
          }
        }
      }
    }
  </script>
  <style>
    body { background-color: #000 !important; color: #fff !important; font-family: "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; position: relative; min-height: 100vh; }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -2;
      background: url('https://i.imgur.com/naK1hruh.jpg');
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      filter: grayscale(20%) brightness(90%);
      opacity: 0.3;
      transform: translateZ(0);
      pointer-events: none;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background: rgba(0, 0, 0, 0.55);
      pointer-events: none;
    }

    section.bg-black { background-color: transparent !important; }
    footer.bg-black { background-color: rgba(0, 0, 0, 0.78) !important; }
    .border.bg-black { background-color: rgba(0, 0, 0, 0.72) !important; }

    html { scroll-behavior: smooth; }
    .font-serif { font-family: "Gravitas One", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif !important; }
    .font-sans { font-family: "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; }
    .font-gothic { font-family: "Special Gothic Expanded One", "Zalando Sans Expanded", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji" !important; }
    .page-enter { animation: pageEnter 700ms cubic-bezier(0.22, 1, 0.36, 1) both; }
    @keyframes pageEnter {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .lux-link { position: relative; }
    .lux-link::after { content: ""; position: absolute; left: 0; bottom: -2px; width: 100%; height: 1px; background: #e10600; transform: scaleX(0); transform-origin: left; transition: transform 240ms ease; }
    .lux-link:hover::after { transform: scaleX(1); }
    .glow-cta { position: relative; }
    .glow-cta::before { content: ""; position: absolute; inset: -2px; background: radial-gradient(60% 60% at 50% 50%, rgba(225, 6, 0, 0.55) 0%, rgba(225, 6, 0, 0) 70%); filter: blur(10px); opacity: 0.85; z-index: -1; }
    .glow-cta { animation: ctaPulse 2.6s ease-in-out infinite; }
    @keyframes ctaPulse {
      0%, 100% { transform: translateY(0); box-shadow: 0 0 0 rgba(225, 6, 0, 0); }
      50% { transform: translateY(-1px); box-shadow: 0 0 34px rgba(225, 6, 0, 0.35); }
    }

    .motion {
      transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease, opacity 160ms ease, background-color 160ms ease, border-color 160ms ease;
      will-change: transform;
    }

    .motion:active {
      transform: scale(0.98);
    }

    .glow-primary {
      box-shadow: 0 0 0 rgba(225, 6, 0, 0);
    }

    .glow-primary:hover {
      box-shadow: 0 0 26px rgba(225, 6, 0, 0.28);
      filter: drop-shadow(0 0 10px rgba(225, 6, 0, 0.22));
    }

    #site-nav.nav-scrolled {
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
      background-color: rgba(0, 0, 0, 0.82);
    }

    @media (prefers-reduced-motion: reduce) {
      html { scroll-behavior: auto; }
      .motion, .glow-cta { transition: none !important; animation: none !important; }
    }
    .site-ready .stagger { animation: staggerIn 700ms cubic-bezier(0.22, 1, 0.36, 1) both; }
    @keyframes staggerIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Spider Web Canvas Overlay */
    #spiderWebCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1;
      opacity: 1;
    }

    /* Offsets Table Styles */
    .offsets-table {
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 8px;
      overflow: hidden;
    }
    .offsets-table th {
      background: rgba(225, 6, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.14);
    }
    .offsets-table td {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
    .offset-value {
      font-family: 'Courier New', monospace;
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
    }
  </style>
</head>
<body class="text-white bg-black font-sans page-enter">
  <canvas id="spiderWebCanvas"></canvas>
  <div id="custom-cursor" aria-hidden="true"></div>
  
  <!-- NAVIGATION -->
  <nav id="site-nav" class="fixed top-0 left-0 right-0 z-50 bg-black/90 backdrop-blur-md border-b border-line">
    <div class="max-w-[1400px] mx-auto px-6 py-4 flex justify-between items-center">
      <div class="flex items-center gap-4">
        <a href="strapper.html" class="font-gothic text-2xl font-bold text-white hover:text-brandRed transition">Belatstrap</a>
      </div>
      <div class="hidden md:flex gap-10 text-xs tracking-[0.28em] uppercase">
        <a href="strapper.html#features" class="lux-link hover:opacity-60 transition">Features</a>
        <a href="about.html" class="lux-link hover:opacity-60 transition">About</a>
        <a href="note.html" class="lux-link hover:opacity-60 transition">Note</a>
        <a href="strapper.html#download" class="lux-link hover:opacity-60 transition">Download</a>
        <a href="offsets.html" class="lux-link hover:opacity-60 transition text-brandRed">Offsets</a>
        <a href="strapper.html#faq" class="lux-link hover:opacity-60 transition">FAQ</a>
      </div>
    </div>
  </nav>

  <!-- HERO -->
  <section class="min-h-screen w-full flex items-center justify-center text-center px-6 bg-black">
    <div class="max-w-4xl pt-28 pb-20" data-aos="fade-up">
      <h2 class="font-serif text-5xl md:text-7xl font-semibold mb-6 stagger" style="animation-delay: 60ms;">
        Memory <span class="text-brandRed font-sans tracking-[0.02em]">OFFSETS</span><br />
      </h2>
      <p class="text-white/70 text-lg md:text-xl mb-10 stagger" style="animation-delay: 140ms;">
        Technical documentation and memory offsets for advanced users and developers working with Roblox memory manipulation.
      </p>
      <div class="flex flex-col md:flex-row gap-4 justify-center stagger" style="animation-delay: 220ms;">
        <a href="#offsets-data" class="glow-cta glow-primary motion inline-flex items-center justify-center px-8 py-4 bg-brandRed text-black text-xs tracking-[0.28em] uppercase hover:bg-red-700 transition">View Offsets</a>
        <a href="strapper.html" class="motion inline-flex items-center justify-center px-8 py-4 border border-line text-xs tracking-[0.28em] uppercase hover:bg-white/5 transition">Back to Home</a>
      </div>
    </div>
  </section>

  <!-- OFFSETS DATA -->
  <section id="offsets-data" class="w-full px-6 py-24 bg-black" data-aos="fade-up">
    <div class="max-w-6xl mx-auto">
      <h3 class="font-serif text-4xl font-semibold mb-14 text-center">Memory Offsets Database</h3>
      
      <div class="mb-12">
        <div class="border border-line bg-black p-6 mb-8">
          <h4 class="text-xl font-semibold mb-4 text-brandRed">Latest Version Information</h4>
          <p class="text-white/70 mb-2"><strong>Roblox Client Version:</strong> Latest</p>
          <p class="text-white/70 mb-2"><strong>Last Updated:</strong> <span id="last-updated">2024</span></p>
          <p class="text-white/70"><strong>Status:</strong> <span class="text-green-400">Active</span></p>
        </div>

        <div class="overflow-x-auto">
          <table class="offsets-table w-full text-sm">
            <thead>
              <tr class="text-left">
                <th class="px-6 py-4 text-xs tracking-[0.28em] uppercase">Category</th>
                <th class="px-6 py-4 text-xs tracking-[0.28em] uppercase">Name</th>
                <th class="px-6 py-4 text-xs tracking-[0.28em] uppercase">Offset</th>
                <th class="px-6 py-4 text-xs tracking-[0.28em] uppercase">Type</th>
                <th class="px-6 py-4 text-xs tracking-[0.28em] uppercase">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr class="hover:bg-white/5 transition">
                <td class="px-6 py-4">Rendering</td>
                <td class="px-6 py-4 font-semibold">Graphics Settings</td>
                <td class="px-6 py-4"><span class="offset-value">0x12345678</span></td>
                <td class="px-6 py-4"><span class="text-green-400">DWORD</span></td>
                <td class="px-6 py-4 text-white/70">Controls graphics quality and rendering settings</td>
              </tr>
              <tr class="hover:bg-white/5 transition">
                <td class="px-6 py-4">Network</td>
                <td class="px-6 py-4 font-semibold">Ping Optimizer</td>
                <td class="px-6 py-4"><span class="offset-value">0x87654321</span></td>
                <td class="px-6 py-4"><span class="text-blue-400">FLOAT</span></td>
                <td class="px-6 py-4 text-white/70">Network latency and packet handling optimization</td>
              </tr>
              <tr class="hover:bg-white/5 transition">
                <td class="px-6 py-4">Performance</td>
                <td class="px-6 py-4 font-semibold">FPS Unlock</td>
                <td class="px-6 py-4"><span class="offset-value">0xABCDEF00</span></td>
                <td class="px-6 py-4"><span class="text-yellow-400">BOOL</span></td>
                <td class="px-6 py-4 text-white/70">Frame rate limiter and performance controls</td>
              </tr>
              <tr class="hover:bg-white/5 transition">
                <td class="px-6 py-4">Memory</td>
                <td class="px-6 py-4 font-semibold">Memory Pool</td>
                <td class="px-6 py-4"><span class="offset-value">0x00FEDCBA</span></td>
                <td class="px-6 py-4"><span class="text-purple-400">PTR</span></td>
                <td class="px-6 py-4 text-white/70">Memory allocation and garbage collection settings</td>
              </tr>
              <tr class="hover:bg-white/5 transition">
                <td class="px-6 py-4">Input</td>
                <td class="px-6 py-4 font-semibold">Input Handler</td>
                <td class="px-6 py-4"><span class="offset-value">0x13579BDF</span></td>
                <td class="px-6 py-4"><span class="text-green-400">DWORD</span></td>
                <td class="px-6 py-4 text-white/70">Mouse and keyboard input processing</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- WARNING SECTION -->
      <div class="border border-red-500/30 bg-red-900/10 p-6 rounded-lg">
        <h4 class="text-lg font-semibold mb-3 text-red-400">⚠️ Important Notice</h4>
        <p class="text-white/70 leading-relaxed">
          These memory offsets are intended for educational and research purposes only. Using these offsets may violate Roblox's Terms of Service 
          and could result in account suspension or termination. Always use caution and ensure compliance with applicable laws and regulations.
        </p>
      </div>
    </div>
  </section>

  <!-- DISCLAIMER -->
  <section class="w-full px-6 py-16 bg-black border-t border-line" data-aos="fade-up">
    <div class="max-w-4xl mx-auto text-center">
      <h3 class="font-serif text-2xl font-semibold mb-6">Disclaimer</h3>
      <p class="text-white/60 leading-relaxed">
        This information is provided "as is" without warranty of any kind. The offsets may change with Roblox updates and require 
        constant maintenance. Users are responsible for ensuring their use complies with all applicable terms of service and laws.
      </p>
    </div>
  </section>

  <script src="https://unpkg.com/aos@2.3.4/dist/aos.js"></script>
  <script>
    // Multi-Legged Skeletal Creature Cursor Follower
    (function() {
      const canvas = document.getElementById('spiderWebCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      const logoImg = new Image();
      logoImg.crossOrigin = 'anonymous';
      logoImg.src = 'https://i.imgur.com/hoNzUGn.png';

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let mouse = {
          x: canvas.width / 2,
          y: canvas.height / 2
      };

      // Enhanced skeletal creature with multiple legs
      class SkeletalCreature {
          constructor() {
              // Main body position
              this.head = { x: mouse.x, y: mouse.y };
              this.targetX = mouse.x;
              this.targetY = mouse.y;
              this.velocity = { x: 0, y: 0 };
              this.angle = 0;
              this.targetAngle = 0;
              
              // Spinal cord segments
              this.spineSegments = 25;
              this.segmentLength = 8;
              this.spine = [];
              
              for (let i = 0; i < this.spineSegments; i++) {
                  this.spine.push({
                      x: mouse.x,
                      y: mouse.y,
                      angle: 0,
                      size: 8 - (i * 0.22),
                      targetX: mouse.x,
                      targetY: mouse.y
                  });
              }
              
              // Multiple pairs of legs (like a centipede/lizard)
              this.legPairs = 8;
              this.legs = [];
              this.stepCycle = 0;
              this.isMoving = false;
              
              for (let i = 0; i < this.legPairs; i++) {
                  // Left leg
                  this.legs.push({
                      side: 'left',
                      segmentIndex: Math.floor(3 + i * 2.5),
                      phase: (i / this.legPairs) * Math.PI * 2,
                      stepHeight: 0,
                      footX: mouse.x,
                      footY: mouse.y,
                      targetFootX: mouse.x,
                      targetFootY: mouse.y,
                      isLifted: false,
                      upperLength: 20,
                      lowerLength: 18
                  });
                  
                  // Right leg
                  this.legs.push({
                      side: 'right',
                      segmentIndex: Math.floor(3 + i * 2.5),
                      phase: (i / this.legPairs) * Math.PI * 2 + Math.PI,
                      stepHeight: 0,
                      footX: mouse.x,
                      footY: mouse.y,
                      targetFootX: mouse.x,
                      targetFootY: mouse.y,
                      isLifted: false,
                      upperLength: 20,
                      lowerLength: 18
                  });
              }
          }

          update() {
              // Calculate distance to mouse
              const dx = mouse.x - this.head.x;
              const dy = mouse.y - this.head.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Only move if cursor is far enough
              if (distance > 80) {
                  this.targetX = mouse.x;
                  this.targetY = mouse.y;
                  this.isMoving = true;
              } else {
                  this.isMoving = false;
              }
              
              // Smooth velocity-based movement
              const targetVelX = (this.targetX - this.head.x) * 0.015;
              const targetVelY = (this.targetY - this.head.y) * 0.015;
              
              this.velocity.x += (targetVelX - this.velocity.x) * 0.1;
              this.velocity.y += (targetVelY - this.velocity.y) * 0.1;
              
              this.head.x += this.velocity.x;
              this.head.y += this.velocity.y;
              
              // Calculate movement angle
              const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
              if (speed > 0.1) {
                  this.targetAngle = Math.atan2(this.velocity.y, this.velocity.x);
              }
              
              // Smooth angle rotation
              let angleDiff = this.targetAngle - this.angle;
              while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
              while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
              this.angle += angleDiff * 0.1;
              
              // Update step cycle
              if (this.isMoving) {
                  this.stepCycle += speed * 0.3;
              }
              
              // Update spine using FABRIK-like algorithm
              this.updateSpine();
              
              // Update legs
              this.updateLegs();
          }

          updateSpine() {
              // Head follows main position
              this.spine[0].x = this.head.x;
              this.spine[0].y = this.head.y;
              this.spine[0].angle = this.angle;
              
              // Forward pass - follow the head
              for (let i = 1; i < this.spine.length; i++) {
                  const prev = this.spine[i - 1];
                  const curr = this.spine[i];
                  
                  const dx = curr.x - prev.x;
                  const dy = curr.y - prev.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  
                  if (dist > 0) {
                      const angle = Math.atan2(dy, dx);
                      curr.x = prev.x + Math.cos(angle) * this.segmentLength;
                      curr.y = prev.y + Math.sin(angle) * this.segmentLength;
                      curr.angle = angle;
                  }
                  
                  // Add slight serpentine motion
                  const wave = Math.sin(this.stepCycle * 0.15 + i * 0.4) * 2;
                  const perpAngle = curr.angle + Math.PI / 2;
                  curr.x += Math.cos(perpAngle) * wave;
                  curr.y += Math.sin(perpAngle) * wave;
              }
              
              // Backward pass - smooth out the spine
              for (let i = this.spine.length - 2; i >= 0; i--) {
                  const curr = this.spine[i];
                  const next = this.spine[i + 1];
                  
                  const dx = next.x - curr.x;
                  const dy = next.y - curr.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  
                  if (dist > this.segmentLength) {
                      const angle = Math.atan2(dy, dx);
                      next.x = curr.x + Math.cos(angle) * this.segmentLength;
                      next.y = curr.y + Math.sin(angle) * this.segmentLength;
                  }
              }
          }

          updateLegs() {
              this.legs.forEach((leg, index) => {
                  // Get attachment point on spine
                  const segment = this.spine[Math.min(leg.segmentIndex, this.spine.length - 1)];
                  const perpAngle = segment.angle + Math.PI / 2;
                  const offset = leg.side === 'left' ? -1 : 1;
                  
                  const hipX = segment.x + Math.cos(perpAngle) * offset * 8;
                  const hipY = segment.y + Math.sin(perpAngle) * offset * 8;
                  
                  // Calculate walking cycle
                  const cyclePos = Math.sin(this.stepCycle + leg.phase);
                  
                  // Check if leg should step
                  const strideLength = 25;
                  const stepForward = segment.angle + (leg.side === 'left' ? Math.PI / 4 : -Math.PI / 4);
                  
                  if (this.isMoving && cyclePos > 0 && !leg.isLifted) {
                      // Lift leg and set new target
                      leg.isLifted = true;
                      leg.targetFootX = hipX + Math.cos(stepForward) * strideLength;
                      leg.targetFootY = hipY + Math.sin(stepForward) * strideLength;
                  } else if (cyclePos < -0.5) {
                      leg.isLifted = false;
                  }
                  
                  // Animate step
                  if (leg.isLifted) {
                      // Lift foot in arc
                      leg.stepHeight = Math.max(0, Math.sin(cyclePos * Math.PI)) * 15;
                      leg.footX += (leg.targetFootX - leg.footX) * 0.3;
                      leg.footY += (leg.targetFootY - leg.footY) * 0.3;
                  } else {
                      // Foot on ground, drag with body movement
                      leg.stepHeight = 0;
                      leg.footX -= this.velocity.x * 0.5;
                      leg.footY -= this.velocity.y * 0.5;
                  }
              });
          }

          solveIK(startX, startY, endX, endY, upperLength, lowerLength) {
              // Two-bone IK solver
              const dx = endX - startX;
              const dy = endY - startY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Clamp distance
              const maxReach = upperLength + lowerLength;
              const clampedDist = Math.min(distance, maxReach * 0.99);
              
              // Law of cosines for angles
              const upperAngle = Math.acos(
                  (upperLength ** 2 + clampedDist ** 2 - lowerLength ** 2) /
                  (2 * upperLength * clampedDist)
              );
              
              const baseAngle = Math.atan2(dy, dx);
              const angle1 = baseAngle + upperAngle;
              
              const jointX = startX + Math.cos(angle1) * upperLength;
              const jointY = startY + Math.sin(angle1) * upperLength;
              
              return {
                  jointX,
                  jointY,
                  angle1,
                  angle2: Math.atan2(endY - jointY, endX - jointX)
              };
          }

          drawBone(x1, y1, x2, y2, thickness, opacity) {
              const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
              const angle = Math.atan2(y2 - y1, x2 - x1);
              
              ctx.save();
              ctx.globalAlpha = opacity;
              ctx.shadowColor = 'rgba(255, 255, 255, 0)';
              ctx.shadowBlur = 0;
              ctx.translate(x1, y1);
              ctx.rotate(angle);
              
              // Bone shape (wider in middle, tapered at ends)
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.quadraticCurveTo(length * 0.3, -thickness, length * 0.5, -thickness * 0.8);
              ctx.quadraticCurveTo(length * 0.7, -thickness, length, 0);
              ctx.quadraticCurveTo(length * 0.7, thickness, length * 0.5, thickness * 0.8);
              ctx.quadraticCurveTo(length * 0.3, thickness, 0, 0);
              ctx.fill();
              
              // Bone highlights
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(length, 0);
              ctx.stroke();
              
              ctx.restore();
          }

          draw() {
              // Draw spinal cord connective tissue
              ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
              ctx.lineWidth = 5;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.moveTo(this.spine[0].x, this.spine[0].y);
              for (let i = 1; i < this.spine.length; i++) {
                  ctx.lineTo(this.spine[i].x, this.spine[i].y);
              }
              ctx.stroke();

              // Draw legs (behind spine)
              this.legs.forEach((leg, index) => {
                  const segment = this.spine[Math.min(leg.segmentIndex, this.spine.length - 1)];
                  const perpAngle = segment.angle + Math.PI / 2;
                  const offset = leg.side === 'left' ? -1 : 1;
                  
                  const hipX = segment.x + Math.cos(perpAngle) * offset * 8;
                  const hipY = segment.y + Math.sin(perpAngle) * offset * 8;
                  
                  const footX = leg.footX;
                  const footY = leg.footY - leg.stepHeight;
                  
                  const ik = this.solveIK(hipX, hipY, footX, footY, leg.upperLength, leg.lowerLength);
                  
                  const opacity = 0.7;
                  
                  // Upper leg bone
                  this.drawBone(hipX, hipY, ik.jointX, ik.jointY, 3, opacity);
                  
                  // Lower leg bone
                  this.drawBone(ik.jointX, ik.jointY, footX, footY, 2.5, opacity);
                  
                  // Joints
                  ctx.save();
                  ctx.globalAlpha = opacity;
                  ctx.fillStyle = '#c0c0c0';
                  ctx.beginPath();
                  ctx.arc(hipX, hipY, 4, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.beginPath();
                  ctx.arc(ik.jointX, ik.jointY, 3.5, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.beginPath();
                  ctx.arc(footX, footY, 3, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.restore();
              });

              // Draw ribs
              for (let i = 3; i < this.spine.length - 3; i += 2) {
                  const segment = this.spine[i];
                  const opacity = (1 - (i / this.spine.length)) * 0.5;
                  const ribLength = 22 - (i * 0.5);
                  
                  if (ribLength > 5) {
                      const perpAngle = segment.angle + Math.PI / 2;
                      
                      // Left rib
                      const leftEndX = segment.x + Math.cos(perpAngle) * -ribLength;
                      const leftEndY = segment.y + Math.sin(perpAngle) * -ribLength;
                      this.drawBone(segment.x, segment.y, leftEndX, leftEndY, 2, opacity);
                      
                      // Right rib
                      const rightEndX = segment.x + Math.cos(perpAngle) * ribLength;
                      const rightEndY = segment.y + Math.sin(perpAngle) * ribLength;
                      this.drawBone(segment.x, segment.y, rightEndX, rightEndY, 2, opacity);
                  }
              }

              // Draw vertebrae
              for (let i = this.spine.length - 1; i >= 0; i--) {
                  const segment = this.spine[i];
                  const opacity = 1 - (i / this.spine.length) * 0.3;
                  
                  ctx.save();
                  ctx.globalAlpha = opacity;
                  
                  // Outer glow
                  ctx.fillStyle = 'rgba(220, 220, 220, 0.3)';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size + 2.5, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // Main vertebra
                  ctx.fillStyle = '#e8e8e8';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // Inner ring detail
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 1.5;
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size * 0.65, 0, Math.PI * 2);
                  ctx.stroke();
                  
                  // Spinal canal (center hole)
                  ctx.fillStyle = '#444';
                  ctx.beginPath();
                  ctx.arc(segment.x, segment.y, segment.size * 0.4, 0, Math.PI * 2);
                  ctx.fill();
                  
                  ctx.restore();
              }

              // Draw logo as creature head
              const head = this.spine[0];
              if (logoImg && logoImg.complete && logoImg.naturalWidth > 0) {
                const size = 34;
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(head.angle);
                ctx.drawImage(logoImg, -size / 2, -size / 2, size, size);
                ctx.restore();
              }
          }
      }

      // Create creature
      const creature = new SkeletalCreature();

      function animate() {
          // Clear every frame for crisp rendering (no blurry smear)
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          creature.update();
          creature.draw();

          requestAnimationFrame(animate);
      }

      // Mouse movement
      document.addEventListener('mousemove', (e) => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
      });

      // Resize
      window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
      });

      animate();
    })();
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      AOS.init({
        duration: 900,
        easing: 'ease-out-cubic',
        once: true,
      });

      document.body.classList.add('site-ready');

      const cursor = document.getElementById('custom-cursor');
      if (!cursor) return;

      document.body.classList.add('cursor-ready');

      const move = (e) => {
        cursor.style.setProperty('--cursor-x', e.clientX);
        cursor.style.setProperty('--cursor-y', e.clientY);
      };

      window.addEventListener('mousemove', move, { passive: true });
      window.addEventListener('pointermove', move, { passive: true });

      const isInteractive = (el) => {
        if (!el) return false;
        return !!el.closest('a, button, summary, [role="button"], input, textarea, select, label');
      };

      window.addEventListener('mouseover', (e) => {
        if (isInteractive(e.target)) cursor.classList.add('is-pointer');
      }, { passive: true });

      window.addEventListener('mouseout', (e) => {
        if (isInteractive(e.target)) cursor.classList.remove('is-pointer');
      }, { passive: true });

      // Update last updated date
      const lastUpdated = document.getElementById('last-updated');
      if (lastUpdated) {
        lastUpdated.textContent = new Date().getFullYear();
      }
    });
  </script>
</body>
</html>
